// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KEYFRAME_PICO_MR_FLAT_H_
#define FLATBUFFERS_GENERATED_KEYFRAME_PICO_MR_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace pico_MR {
namespace flat {

struct Point2f;

struct Point3f;

struct MatXd;
struct MatXdBuilder;

struct MatXf;
struct MatXfBuilder;

struct MatXu;
struct MatXuBuilder;

struct Word;

struct KeyFrame;
struct KeyFrameBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Point2f()
      : x_(0),
        y_(0) {
  }
  Point2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Point2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Point3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Point3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Point3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Word FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  float var_;

 public:
  Word()
      : index_(0),
        var_(0) {
  }
  Word(int32_t _index, float _var)
      : index_(flatbuffers::EndianScalar(_index)),
        var_(flatbuffers::EndianScalar(_var)) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  float var() const {
    return flatbuffers::EndianScalar(var_);
  }
};
FLATBUFFERS_STRUCT_END(Word, 8);

struct MatXd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatXdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS) &&
           VerifyField<int32_t>(verifier, VT_COLS) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MatXdBuilder {
  typedef MatXd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(MatXd::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(MatXd::VT_COLS, cols, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(MatXd::VT_DATA, data);
  }
  explicit MatXdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatXd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatXd>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatXd> CreateMatXd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  MatXdBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatXd> CreateMatXdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return pico_MR::flat::CreateMatXd(
      _fbb,
      rows,
      cols,
      data__);
}

struct MatXf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatXfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS) &&
           VerifyField<int32_t>(verifier, VT_COLS) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MatXfBuilder {
  typedef MatXf Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(MatXf::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(MatXf::VT_COLS, cols, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(MatXf::VT_DATA, data);
  }
  explicit MatXfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatXf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatXf>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatXf> CreateMatXf(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  MatXfBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatXf> CreateMatXfDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return pico_MR::flat::CreateMatXf(
      _fbb,
      rows,
      cols,
      data__);
}

struct MatXu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatXuBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS) &&
           VerifyField<int32_t>(verifier, VT_COLS) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MatXuBuilder {
  typedef MatXu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(MatXu::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(MatXu::VT_COLS, cols, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MatXu::VT_DATA, data);
  }
  explicit MatXuBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatXu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatXu>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatXu> CreateMatXu(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MatXuBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatXu> CreateMatXuDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return pico_MR::flat::CreateMatXu(
      _fbb,
      rows,
      cols,
      data__);
}

struct KeyFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CAMERA_ID = 6,
    VT_KEY_POINTS = 8,
    VT_MAP_POINT_IDS = 10,
    VT_TCW = 12,
    VT_LOCAL_DESCRIPTORS = 14,
    VT_WORDS = 16,
    VT_NUM_FEATURES = 18,
    VT_IMG_PATH = 20,
    VT_TIME_STAMP = 22,
    VT_INTRINSIC = 24,
    VT_DIST_MODE = 26,
    VT_DIST_COEFF = 28,
    VT_ANCHOR_UUIDS = 30,
    VT_LOCAL_DESCRIPTORS_UINT8 = 32,
    VT_MAP_POINTS = 34
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t camera_id() const {
    return GetField<int32_t>(VT_CAMERA_ID, 0);
  }
  const flatbuffers::Vector<const pico_MR::flat::Point2f *> *key_points() const {
    return GetPointer<const flatbuffers::Vector<const pico_MR::flat::Point2f *> *>(VT_KEY_POINTS);
  }
  const flatbuffers::Vector<int32_t> *map_point_ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MAP_POINT_IDS);
  }
  const pico_MR::flat::MatXd *tcw() const {
    return GetPointer<const pico_MR::flat::MatXd *>(VT_TCW);
  }
  const pico_MR::flat::MatXf *local_descriptors() const {
    return GetPointer<const pico_MR::flat::MatXf *>(VT_LOCAL_DESCRIPTORS);
  }
  const flatbuffers::Vector<const pico_MR::flat::Word *> *words() const {
    return GetPointer<const flatbuffers::Vector<const pico_MR::flat::Word *> *>(VT_WORDS);
  }
  int32_t num_features() const {
    return GetField<int32_t>(VT_NUM_FEATURES, 0);
  }
  const flatbuffers::String *img_path() const {
    return GetPointer<const flatbuffers::String *>(VT_IMG_PATH);
  }
  int64_t time_stamp() const {
    return GetField<int64_t>(VT_TIME_STAMP, 0);
  }
  const pico_MR::flat::MatXd *intrinsic() const {
    return GetPointer<const pico_MR::flat::MatXd *>(VT_INTRINSIC);
  }
  const flatbuffers::String *dist_mode() const {
    return GetPointer<const flatbuffers::String *>(VT_DIST_MODE);
  }
  const pico_MR::flat::MatXd *dist_coeff() const {
    return GetPointer<const pico_MR::flat::MatXd *>(VT_DIST_COEFF);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *anchor_uuids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ANCHOR_UUIDS);
  }
  const pico_MR::flat::MatXu *local_descriptors_uint8() const {
    return GetPointer<const pico_MR::flat::MatXu *>(VT_LOCAL_DESCRIPTORS_UINT8);
  }
  const flatbuffers::Vector<const pico_MR::flat::Point3f *> *map_points() const {
    return GetPointer<const flatbuffers::Vector<const pico_MR::flat::Point3f *> *>(VT_MAP_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_CAMERA_ID) &&
           VerifyOffset(verifier, VT_KEY_POINTS) &&
           verifier.VerifyVector(key_points()) &&
           VerifyOffset(verifier, VT_MAP_POINT_IDS) &&
           verifier.VerifyVector(map_point_ids()) &&
           VerifyOffset(verifier, VT_TCW) &&
           verifier.VerifyTable(tcw()) &&
           VerifyOffset(verifier, VT_LOCAL_DESCRIPTORS) &&
           verifier.VerifyTable(local_descriptors()) &&
           VerifyOffset(verifier, VT_WORDS) &&
           verifier.VerifyVector(words()) &&
           VerifyField<int32_t>(verifier, VT_NUM_FEATURES) &&
           VerifyOffset(verifier, VT_IMG_PATH) &&
           verifier.VerifyString(img_path()) &&
           VerifyField<int64_t>(verifier, VT_TIME_STAMP) &&
           VerifyOffset(verifier, VT_INTRINSIC) &&
           verifier.VerifyTable(intrinsic()) &&
           VerifyOffset(verifier, VT_DIST_MODE) &&
           verifier.VerifyString(dist_mode()) &&
           VerifyOffset(verifier, VT_DIST_COEFF) &&
           verifier.VerifyTable(dist_coeff()) &&
           VerifyOffset(verifier, VT_ANCHOR_UUIDS) &&
           verifier.VerifyVector(anchor_uuids()) &&
           verifier.VerifyVectorOfStrings(anchor_uuids()) &&
           VerifyOffset(verifier, VT_LOCAL_DESCRIPTORS_UINT8) &&
           verifier.VerifyTable(local_descriptors_uint8()) &&
           VerifyOffset(verifier, VT_MAP_POINTS) &&
           verifier.VerifyVector(map_points()) &&
           verifier.EndTable();
  }
};

struct KeyFrameBuilder {
  typedef KeyFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_ID, id, 0);
  }
  void add_camera_id(int32_t camera_id) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_CAMERA_ID, camera_id, 0);
  }
  void add_key_points(flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Point2f *>> key_points) {
    fbb_.AddOffset(KeyFrame::VT_KEY_POINTS, key_points);
  }
  void add_map_point_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> map_point_ids) {
    fbb_.AddOffset(KeyFrame::VT_MAP_POINT_IDS, map_point_ids);
  }
  void add_tcw(flatbuffers::Offset<pico_MR::flat::MatXd> tcw) {
    fbb_.AddOffset(KeyFrame::VT_TCW, tcw);
  }
  void add_local_descriptors(flatbuffers::Offset<pico_MR::flat::MatXf> local_descriptors) {
    fbb_.AddOffset(KeyFrame::VT_LOCAL_DESCRIPTORS, local_descriptors);
  }
  void add_words(flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Word *>> words) {
    fbb_.AddOffset(KeyFrame::VT_WORDS, words);
  }
  void add_num_features(int32_t num_features) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_NUM_FEATURES, num_features, 0);
  }
  void add_img_path(flatbuffers::Offset<flatbuffers::String> img_path) {
    fbb_.AddOffset(KeyFrame::VT_IMG_PATH, img_path);
  }
  void add_time_stamp(int64_t time_stamp) {
    fbb_.AddElement<int64_t>(KeyFrame::VT_TIME_STAMP, time_stamp, 0);
  }
  void add_intrinsic(flatbuffers::Offset<pico_MR::flat::MatXd> intrinsic) {
    fbb_.AddOffset(KeyFrame::VT_INTRINSIC, intrinsic);
  }
  void add_dist_mode(flatbuffers::Offset<flatbuffers::String> dist_mode) {
    fbb_.AddOffset(KeyFrame::VT_DIST_MODE, dist_mode);
  }
  void add_dist_coeff(flatbuffers::Offset<pico_MR::flat::MatXd> dist_coeff) {
    fbb_.AddOffset(KeyFrame::VT_DIST_COEFF, dist_coeff);
  }
  void add_anchor_uuids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> anchor_uuids) {
    fbb_.AddOffset(KeyFrame::VT_ANCHOR_UUIDS, anchor_uuids);
  }
  void add_local_descriptors_uint8(flatbuffers::Offset<pico_MR::flat::MatXu> local_descriptors_uint8) {
    fbb_.AddOffset(KeyFrame::VT_LOCAL_DESCRIPTORS_UINT8, local_descriptors_uint8);
  }
  void add_map_points(flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Point3f *>> map_points) {
    fbb_.AddOffset(KeyFrame::VT_MAP_POINTS, map_points);
  }
  explicit KeyFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyFrame> CreateKeyFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t camera_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Point2f *>> key_points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> map_point_ids = 0,
    flatbuffers::Offset<pico_MR::flat::MatXd> tcw = 0,
    flatbuffers::Offset<pico_MR::flat::MatXf> local_descriptors = 0,
    flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Word *>> words = 0,
    int32_t num_features = 0,
    flatbuffers::Offset<flatbuffers::String> img_path = 0,
    int64_t time_stamp = 0,
    flatbuffers::Offset<pico_MR::flat::MatXd> intrinsic = 0,
    flatbuffers::Offset<flatbuffers::String> dist_mode = 0,
    flatbuffers::Offset<pico_MR::flat::MatXd> dist_coeff = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> anchor_uuids = 0,
    flatbuffers::Offset<pico_MR::flat::MatXu> local_descriptors_uint8 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const pico_MR::flat::Point3f *>> map_points = 0) {
  KeyFrameBuilder builder_(_fbb);
  builder_.add_time_stamp(time_stamp);
  builder_.add_map_points(map_points);
  builder_.add_local_descriptors_uint8(local_descriptors_uint8);
  builder_.add_anchor_uuids(anchor_uuids);
  builder_.add_dist_coeff(dist_coeff);
  builder_.add_dist_mode(dist_mode);
  builder_.add_intrinsic(intrinsic);
  builder_.add_img_path(img_path);
  builder_.add_num_features(num_features);
  builder_.add_words(words);
  builder_.add_local_descriptors(local_descriptors);
  builder_.add_tcw(tcw);
  builder_.add_map_point_ids(map_point_ids);
  builder_.add_key_points(key_points);
  builder_.add_camera_id(camera_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyFrame> CreateKeyFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t camera_id = 0,
    const std::vector<pico_MR::flat::Point2f> *key_points = nullptr,
    const std::vector<int32_t> *map_point_ids = nullptr,
    flatbuffers::Offset<pico_MR::flat::MatXd> tcw = 0,
    flatbuffers::Offset<pico_MR::flat::MatXf> local_descriptors = 0,
    const std::vector<pico_MR::flat::Word> *words = nullptr,
    int32_t num_features = 0,
    const char *img_path = nullptr,
    int64_t time_stamp = 0,
    flatbuffers::Offset<pico_MR::flat::MatXd> intrinsic = 0,
    const char *dist_mode = nullptr,
    flatbuffers::Offset<pico_MR::flat::MatXd> dist_coeff = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *anchor_uuids = nullptr,
    flatbuffers::Offset<pico_MR::flat::MatXu> local_descriptors_uint8 = 0,
    const std::vector<pico_MR::flat::Point3f> *map_points = nullptr) {
  auto key_points__ = key_points ? _fbb.CreateVectorOfStructs<pico_MR::flat::Point2f>(*key_points) : 0;
  auto map_point_ids__ = map_point_ids ? _fbb.CreateVector<int32_t>(*map_point_ids) : 0;
  auto words__ = words ? _fbb.CreateVectorOfStructs<pico_MR::flat::Word>(*words) : 0;
  auto img_path__ = img_path ? _fbb.CreateString(img_path) : 0;
  auto dist_mode__ = dist_mode ? _fbb.CreateString(dist_mode) : 0;
  auto anchor_uuids__ = anchor_uuids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*anchor_uuids) : 0;
  auto map_points__ = map_points ? _fbb.CreateVectorOfStructs<pico_MR::flat::Point3f>(*map_points) : 0;
  return pico_MR::flat::CreateKeyFrame(
      _fbb,
      id,
      camera_id,
      key_points__,
      map_point_ids__,
      tcw,
      local_descriptors,
      words__,
      num_features,
      img_path__,
      time_stamp,
      intrinsic,
      dist_mode__,
      dist_coeff,
      anchor_uuids__,
      local_descriptors_uint8,
      map_points__);
}

inline const pico_MR::flat::KeyFrame *GetKeyFrame(const void *buf) {
  return flatbuffers::GetRoot<pico_MR::flat::KeyFrame>(buf);
}

inline const pico_MR::flat::KeyFrame *GetSizePrefixedKeyFrame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<pico_MR::flat::KeyFrame>(buf);
}

inline bool VerifyKeyFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<pico_MR::flat::KeyFrame>(nullptr);
}

inline bool VerifySizePrefixedKeyFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<pico_MR::flat::KeyFrame>(nullptr);
}

inline void FinishKeyFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<pico_MR::flat::KeyFrame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedKeyFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<pico_MR::flat::KeyFrame> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace pico_MR

#endif  // FLATBUFFERS_GENERATED_KEYFRAME_PICO_MR_FLAT_H_
